// Generated by TaroBase SDK Generator: 2025-11-12T04:22:12.036Z
// Edits may be overwritten by subsequent runs!

import { get, set, subscribe, setMany as tarobaseSetMany } from '@pooflabs/server';
import { getFiles, setFile } from '@pooflabs/server';
import { PublicKey } from '@solana/web3.js';
import { runQuery } from '@pooflabs/server'; 


// --- SDK Utilities ---

/**
 * Helper function to check if a value is a Time.Now value
 */
const isServerTimeNow = (value: any): value is TimeOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "time" &&
    value.value === "now"
  );
};

/**
 * Helper function to check if a value is an Increment operation
 */
const isIncrementOperation = (value: any): value is IncrementOperation => {
  return (
    value &&
    typeof value === "object" &&
    value.operation === "increment" &&
    typeof value.value === "number"
  );
};

/**
 * Time utility for server-time values
 *
 * Use this when you want to store the current server time in a numeric field
 *
 * Example:
 * // For a schema with { createdAt: "Int" } or { createdAt: "UInt" }
 * await setPost("123", {
 *   title: "My Post",
 *   createdAt: Time.Now  // Will be stored as the server's current timestamp
 * });
 */
export interface TimeOperation {
  operation: string;
  value: string;
}

/**
 * Increment utility for incrementing/decrementing numeric fields
 *
 * Use this when you want to increment or decrement a numeric field by a specific amount
 *
 * Example:
 * // For a schema with { viewCount: "UInt" } or { balance: "Int" }
 * await updatePost("123", {
 *   viewCount: Increment.by(1)  // Increments viewCount by 1
 * });
 * await updateAccount("456", {
 *   balance: Increment.by(-50)  // Decrements balance by 50
 * });
 */
export interface IncrementOperation {
  operation: string;
  value: number;
}

export type TokenName = 'USDC' | 'SOL' | 'other';
export interface TokenAmount {
  type: 'token';
  name: TokenName;
  amount: number; // User-friendly amount (e.g., 10.5 SOL)
}

/**
 * AddressType represents a Solana public key for use in request data.
 */
export interface AddressType {
  type: 'address';
  publicKey: PublicKey | string;
}

/**
 * Helper function to check if a value is a TokenAmount value
 */
const isTokenAmount = (value: any): value is TokenAmount => {
  return value && typeof value === 'object' && value.type === 'token';
};

/**
 * Helper function to check if a value is an AddressType value
 */
const isAddressType = (value: any): value is AddressType => {
    // Check for the 'address' type property and that publicKey is an instance of PublicKey
    return value && typeof value === 'object' && value.type === 'address';
};


/**
 * Transforms special values (Time.now, Token.amount, Address.publicKey) in an object
 * to the format expected by the backend before sending the request.
 * This function is recursive and handles nested objects and arrays.
 */
const transformValues = (data: any): any => {
  // Handle null or non-object/array types directly
  if (!data || typeof data !== 'object') {
    return data;
  }

  // Check for specific object types first using type guards
  if (isServerTimeNow(data)) {
    // Pass Time.Now object as is; backend interprets it
    return { operation: 'time', value: 'now' };
  } else if (isIncrementOperation(data)) {
    // Pass Increment operation as is; backend interprets it
    return { operation: 'increment', value: data.value };
  } else if (isTokenAmount(data)) {
    // Convert user-friendly amount to backend's integer format based on decimals
    const { name, amount } = data; // Safe access due to type guard
    if (name === 'USDC') {
      return Math.round(amount * 10 ** 6); // 6 decimals for USDC
    } else if (name === 'SOL') {
      return Math.round(amount * 10 ** 9); // 9 decimals for SOL
    } else {
      // Assume a default of 6 decimals for custom tokens
      return Math.round(amount * 10 ** 6);
    }
  } else if (isAddressType(data)) {
     // Convert AddressType to its base58 string representation for the backend
     if (typeof data.publicKey === 'string') {
      return data.publicKey;
     } else {
      return data.publicKey.toBase58(); // Safe access due to type guard
     }
  }

  // Handle arrays: recursively transform each item
  if (Array.isArray(data)) {
    // Use map with explicit typing for clarity
    return data.map((item: any) => transformValues(item));
  }

  // Handle regular objects: recursively transform each property
  // Create a new object to avoid modifying the original
  const result: Record<string, any> = {};
  for (const key in data) {
    // Use safer check for own properties
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      result[key] = transformValues(data[key]);
    }
  }
  return result;
};

// --- SDK Helper Objects ---

export const Token: {
  /**
   * Creates a TokenAmount object representing a specific amount of a token.
   * @param name The name of the token (e.g., 'USDC', 'SOL').
   * @param amount The user-friendly amount (e.g., 10.5 for 10.5 USDC).
   */
  amount: (name: TokenName, amount: number) => TokenAmount;
  /**
   * Converts a TokenAmount object back to its integer representation based on decimals.
   * Useful if you need the raw integer value on the client side.
   */
  convert: (amount: TokenAmount) => number;
} = {
  amount: (name: TokenName, amount: number): TokenAmount => ({
    type: 'token',
    name,
    amount,
  }),
  convert: (amount: TokenAmount): number => {
    // This logic mirrors the transformation in transformValues
    if (amount.name === 'USDC') {
      return Math.round(amount.amount * 10 ** 6);
    } else if (amount.name === 'SOL') {
      return Math.round(amount.amount * 10 ** 9);
    }
    return Math.round(amount.amount * 10 ** 6); // Default or handle 'other'
  },
};

export const Time: {
  /**
   * Represents the server's current time. Use this value for 'Int' or 'UInt' fields
   * in request data where you want the server to insert the timestamp.
   */
  Now: TimeOperation;
} = {
  Now: { operation: "time", value: "now" }
};

export const Increment: {
  /**
   * Creates an increment/decrement operation for numeric fields.
   * Use positive values to increment, negative values to decrement.
   * @param value The amount to increment (positive) or decrement (negative)
   *
   * Example:
   * // Increment a counter by 1
   * await updatePost("123", { viewCount: Increment.by(1) });
   *
   * // Decrement a balance by 50
   * await updateAccount("456", { balance: Increment.by(-50) });
   */
  by: (value: number) => IncrementOperation;
} = {
  by: (value: number): IncrementOperation => ({
    operation: "increment",
    value
  })
};

export const Address: {
  /**
   * Creates an AddressType object from a PublicKey instance or a base58 string.
   * Validates the input and throws an error if invalid.
   * @param key A PublicKey instance or a base58 encoded public key string.
   */
  publicKey: (key: PublicKey | string) => AddressType;
} = {
  publicKey: (key: PublicKey | string): AddressType => {
    let pkInstance: PublicKey;
    if (typeof key === 'string') {
      try {
        // Validate and create PublicKey from string
        pkInstance = new PublicKey(key);
      } catch (e) {
        // Safer error handling
        const message = e instanceof Error ? e.message : String(e);
        console.error(`Invalid public key string provided: ${key}`, message);
        throw new Error(`Invalid public key string: ${key}`);
      }
    } else if (key instanceof PublicKey) {
       // Use the provided PublicKey instance directly
      pkInstance = key;
    } else {
      // Handle invalid input type
      throw new Error('Invalid input for Address.publicKey: Must be a PublicKey instance or a base58 string.');
    }
    // Return the structured AddressType object
    return {
      type: 'address',
      publicKey: pkInstance,
    };
  },
};

// --- Common Interfaces ---
/**
 * Common metadata fields added by TaroBase to document responses.
 */
export interface TarobaseMetadata {
  id: string;
  tarobase_created_at: number; // epoch milliseconds
}

/**
 * Represents a file stored in TaroBase Storage.
 */
export interface FileItem {
  path: string; // Full path within storage
  url: string;  // Publicly accessible URL
}

/**
 * Represents a document operation for use with setMany.
 * Used by build functions to create properly typed operations.
 */
export interface DocumentOperation {
  path: string;
  document: any;
}

// --- Batch Operations ---

/**
 * Execute multiple document operations in a single batch.
 * @param operations Array of DocumentOperation objects created by build functions
 * @returns Promise resolving to the result of the batch operation
 */
export async function setMany(operations: DocumentOperation[]): Promise<any> {
  return await tarobaseSetMany(operations);
}

// --- Generated Functions by Policy Path ---

// --- Path: scouts/$scoutId ---

export interface ScoutsRequest {
  userId: AddressType;
  name: string;
  description?: string;
  status: string;
  instructions: string;
  resultAction?: string;
  sessionId?: string;
  liveUrl?: string;
  result?: string;
  error?: string;
  startedAt?: number | TimeOperation | IncrementOperation | TokenAmount;
  completedAt?: number | TimeOperation | IncrementOperation | TokenAmount;
  screenshots?: string;
}

export interface ScoutsResponse {
  userId: string;
  name: string;
  description?: string;
  status: string;
  instructions: string;
  resultAction?: string;
  sessionId?: string;
  liveUrl?: string;
  result?: string;
  error?: string;
  startedAt?: number;
  completedAt?: number;
  screenshots?: string;
  id: string;
  tarobase_created_at: number;
}

/**
 * Build a Scouts operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildScouts(scoutId: string, data: ScoutsRequest | null): DocumentOperation {
  const doc = data ? transformValues(data) : null;
  return { path: `scouts/${scoutId}`, document: doc };
}

/**
 * ONLY THE SERVER (PROJECT_VAULT_ADDRESS) can create scouts. This is called by x402-protected API endpoints that authenticate users and create scouts on their behalf, triggering browser-use execution. Required fields are userId (the user the scout belongs to), name, instructions, and status. Status should be set to 'pending' initially. Optional fields include resultAction, sessionId, liveUrl, result, error, startedAt, completedAt, and screenshots which are populated during execution. (Create/Update Single Item)
 */
export async function setScouts(scoutId: string, data: ScoutsRequest | null): Promise<boolean> {
  try {
    const transformedData = data ? transformValues(data) : null;
    const succeeded = await set(`scouts/${scoutId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error setting Scouts: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

export type ScoutsRequestUpdate = Partial<ScoutsRequest>;

/**
 * Build a Scouts update operation for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildUpdateScouts(scoutId: string, data: ScoutsRequestUpdate): DocumentOperation {
  const doc = transformValues(data);
  return { path: `scouts/${scoutId}`, document: doc };
}

/**
 * ONLY THE SERVER (PROJECT_VAULT_ADDRESS) can update scouts to track execution progress. The userId cannot be changed. The server updates status, sessionId, liveUrl, result, error, startedAt, completedAt, and screenshots fields as the browser automation progresses through pending → running → completed/error states. (Update Single Item)
 */
export async function updateScouts(scoutId: string, data: ScoutsRequestUpdate): Promise<boolean> {
  try {
    const transformedData = transformValues(data);
    const succeeded = await set(`scouts/${scoutId}`, transformedData);
    return !!succeeded;
  } catch (error) {
    console.error(`Error updating Scouts: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * 
  Read Operation Details: Authenticated users can read their own scouts (where userId matches their wallet address). The server (PROJECT_VAULT_ADDRESS) can read any scout document to check status and update execution state. Shows all scout fields including execution state, browser session details, results, timing information, and screenshots from browser-use task execution.
   (Get Single Item)
 */
export async function getScouts(scoutId: string): Promise<ScoutsResponse | null> {
  try {
    const result = await get(`scouts/${scoutId}`);
    return result as ScoutsResponse | null;
  } catch (error) {
    console.error(`Error getting Scouts: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}

/**
 * Subscribes to changes in a single Scouts document. (
  Read Operation Details: Authenticated users can read their own scouts (where userId matches their wallet address). The server (PROJECT_VAULT_ADDRESS) can read any scout document to check status and update execution state. Shows all scout fields including execution state, browser session details, results, timing information, and screenshots from browser-use task execution.
  )
 */
export function subscribeScouts(callback: (data: ScoutsResponse | null) => void, scoutId: string): Promise<() => Promise<void>> {
  return subscribe(`scouts/${scoutId}`, { // Use the item's basePath
    onData: (data) => {
      callback(data as ScoutsResponse | null);
    },
    onError: (error) => {
      console.error(`Error subscribing to Scouts at path '${`scouts/${scoutId}`}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get many Scouts items from collection scouts
 
  Read Operation Details: Authenticated users can read their own scouts (where userId matches their wallet address). The server (PROJECT_VAULT_ADDRESS) can read any scout document to check status and update execution state. Shows all scout fields including execution state, browser session details, results, timing information, and screenshots from browser-use task execution.
  
 */
export async function getManyScouts(filter: string = ""): Promise<ScoutsResponse[]> {
  try {
    const results = await get("scouts", { prompt: filter });
    return Array.isArray(results) ? results as ScoutsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Scouts collection at path 'scouts': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Scouts collection at scouts
 
  Read Operation Details: Authenticated users can read their own scouts (where userId matches their wallet address). The server (PROJECT_VAULT_ADDRESS) can read any scout document to check status and update execution state. Shows all scout fields including execution state, browser session details, results, timing information, and screenshots from browser-use task execution.
  
 */
export function subscribeManyScouts(callback: (data: ScoutsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("scouts", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as ScoutsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Scouts collection at path '${"scouts"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * Get all Scouts items from collection scouts
 
  Read Operation Details: Authenticated users can read their own scouts (where userId matches their wallet address). The server (PROJECT_VAULT_ADDRESS) can read any scout document to check status and update execution state. Shows all scout fields including execution state, browser session details, results, timing information, and screenshots from browser-use task execution.
  
 */
export async function getAllScouts(filter: string = ""): Promise<ScoutsResponse[]> {
  try {
    const results = await get("scouts", { prompt: filter });
    return Array.isArray(results) ? results as ScoutsResponse[] : [];
  } catch (error) {
    console.error(`Error getting Scouts collection at path 'scouts': ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

/**
 * Subscribe to changes in Scouts collection at scouts
 
  Read Operation Details: Authenticated users can read their own scouts (where userId matches their wallet address). The server (PROJECT_VAULT_ADDRESS) can read any scout document to check status and update execution state. Shows all scout fields including execution state, browser session details, results, timing information, and screenshots from browser-use task execution.
  
 */
export function subscribeAllScouts(callback: (data: ScoutsResponse[]) => void, filter: string = ""): Promise<() => Promise<void>> {
  return subscribe("scouts", {
    prompt: filter,
    onData: (data) => {
      callback(Array.isArray(data) ? data as ScoutsResponse[] : []);
    },
    onError: (error) => {
       console.error(`Error subscribing to Scouts collection at path '${"scouts"}': ${error instanceof Error ? error.message : String(error)}`);
    }
  });
}

/**
 * 
  Delete Operation Details: Only the scout owner can delete their scout. The userId must match the caller's wallet address. This removes the scout and all its execution history.
   (Delete Single Item)
 */
export async function deleteScouts(scoutId: string): Promise<boolean> {
  try {
    const succeeded = await set(`scouts/${scoutId}`, null);
    return !!succeeded;
  } catch (error) {
    console.error(`Error deleting Scouts: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

/**
 * Build a delete operation for Scouts for use with setMany.
 * @returns A DocumentOperation that can be passed to setMany.
 */
export function buildDeleteScouts(scoutId: string): DocumentOperation {
  return { path: `scouts/${scoutId}`, document: null };
}

// --- End Generated SDK ---
