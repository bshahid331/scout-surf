import { SpeechModelV2, ProviderV2 } from '@ai-sdk/provider';
import { FetchFunction } from '@ai-sdk/provider-utils';

type LMNTConfig = {
    provider: string;
    url: (options: {
        modelId: string;
        path: string;
    }) => string;
    headers: () => Record<string, string | undefined>;
    fetch?: FetchFunction;
    generateId?: () => string;
};

type LMNTSpeechModelId = 'aurora' | 'blizzard' | (string & {});

interface LMNTSpeechModelConfig extends LMNTConfig {
    _internal?: {
        currentDate?: () => Date;
    };
}
declare class LMNTSpeechModel implements SpeechModelV2 {
    readonly modelId: LMNTSpeechModelId;
    private readonly config;
    readonly specificationVersion = "v2";
    get provider(): string;
    constructor(modelId: LMNTSpeechModelId, config: LMNTSpeechModelConfig);
    private getArgs;
    doGenerate(options: Parameters<SpeechModelV2['doGenerate']>[0]): Promise<Awaited<ReturnType<SpeechModelV2['doGenerate']>>>;
}

interface LMNTProvider extends Pick<ProviderV2, 'speechModel'> {
    (modelId: 'aurora', settings?: {}): {
        speech: LMNTSpeechModel;
    };
    /**
  Creates a model for speech synthesis.
     */
    speech(modelId: LMNTSpeechModelId): SpeechModelV2;
}
interface LMNTProviderSettings {
    /**
  API key for authenticating requests.
       */
    apiKey?: string;
    /**
  Custom headers to include in the requests.
       */
    headers?: Record<string, string>;
    /**
  Custom fetch implementation. You can use it as a middleware to intercept requests,
  or to provide a custom fetch implementation for e.g. testing.
      */
    fetch?: FetchFunction;
}
/**
Create an LMNT provider instance.
 */
declare function createLMNT(options?: LMNTProviderSettings): LMNTProvider;
/**
Default LMNT provider instance.
 */
declare const lmnt: LMNTProvider;

declare const VERSION: string;

export { type LMNTProvider, type LMNTProviderSettings, VERSION, createLMNT, lmnt };
